// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: challenges.sql

package queries

import (
	"context"

	"github.com/moroz/go-altcha-video/internal/dbtypes"
)

const insertUsedChallenge = `-- name: InsertUsedChallenge :one
insert into used_altcha_challenges (challenge_hash, expires_at) values (?, ?) returning id, challenge_hash, expires_at, created_at
`

type InsertUsedChallengeParams struct {
	ChallengeHash []byte
	ExpiresAt     dbtypes.UnixTimestamp
}

func (q *Queries) InsertUsedChallenge(ctx context.Context, arg InsertUsedChallengeParams) (*UsedAltchaChallenge, error) {
	row := q.db.QueryRowContext(ctx, insertUsedChallenge, arg.ChallengeHash, arg.ExpiresAt)
	var i UsedAltchaChallenge
	err := row.Scan(
		&i.ID,
		&i.ChallengeHash,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return &i, err
}

const vacuumUsedChallenges = `-- name: VacuumUsedChallenges :exec
delete from used_altcha_challenges where expires_at < unixepoch()
`

func (q *Queries) VacuumUsedChallenges(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, vacuumUsedChallenges)
	return err
}

const validateChallengeReuse = `-- name: ValidateChallengeReuse :one
select cast(exists (select 1 from used_altcha_challenges where challenge_hash = ?) as boolean)
`

func (q *Queries) ValidateChallengeReuse(ctx context.Context, challengeHash []byte) (bool, error) {
	row := q.db.QueryRowContext(ctx, validateChallengeReuse, challengeHash)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}
